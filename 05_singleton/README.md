# Singleton 5　patterns

参考サイト → [JavaのSingleton実装方法５つとメリットデメリット使用場面とかいろいろ書いてみる](https://munchkins-diary.hatenablog.com/entry/2018/11/21/040358)

## 1. 普通のSingleton

実装: ```NormalSingleton.java```
**メリット**
- 実装がシンプル
- スレッドセーフ

**デメリット**
- JVM起動時に必ずインスタンスが生成されるため重いインスタンスには不向き
- コンストラクタがリフレクションでアクセス可能なので厳密にはシングルトンではない

**用途**
- 学習
- サーバーサイドで頻繁に使われることが事前にわかっているクラス
- 重くはないがオブジェクト指向的な意味でSingletonにしたいクラス

## 2. 遅延生成

実装: ```DelaySingleton.java```
**メリット**
- 実装がシンプル
- 重いクラスの生成を、使用直前まで延期できる

**デメリット**
- 非スレッドセーフ
- コンストラクタに加えinstanceまでfinalではないため、リフレクション経由で書き換え可能になり、よりSingletonではなくなる

**用途**
- 学習
- マルチスレッドを使用しないバッチ処理

## 3. SynchronizedでThreadSafe
インスタンスを生成する箇所を同期ブロックで囲み、強固にnewの呼び出しを一回に絞る方法。
実装: ```SynchronizedSingleton.java```
**メリット**
- スレッドセーフ
- 重いクラスの生成を、使用直前まで延期できる

**デメリット**
- 最初の段階で大量にリクエストが来るとsynchronizedはパフォーマンス劣化につながる事がある
- コンストラクタに加えinstanceまでfinalではないため、リフレクション経由で書き換え可能になり、よりSingletonではなくなる
- 冗長で書きづらい上に読みづらい

**用途**
- 学習
- マルチスレッドを多用するバッチ
- tomcat などで運用されるサーバサイドアプリケーション

## 4. Bill Push Singleton
インナークラスのクラス値は初回参照時までメモリに読み込まれないというJavaの言語仕様を利用したSingleton。
実装: ```BillPushSingleton.java```

**メリット**
- 実装がシンプルで簡単
- スレッドセーフ
- 重いインスタンスの生成を使用される直前まで遅延できる
- Synchronizedによるパフォーマンス劣化の心配がない

**デメリット**
- リフレクション経由でインスタンス生成ができるため厳密にはSingletonではない
- JVMやクラスローダの知識がない人に説明するのがだるい（僕がこの記事を書いた一番大きな理由）

**用途**
- マルチスレッドを多用するバッチ
- tomcat などで運用されるサーバサイドアプリケーション

## 5. Enum Singleton
Enumはグローバルに唯一のインスタンスであるというJavaの言語仕様を利用したSingleton。
実装: ```EnumSingleton.java```

**メリット**
- 厳密なSingleton
- スレッドセーフ

**デメリット**
- 実装がキモい、enumにする意味がわからない
- インターフェイスや抽象クラスが使えず、他のデザインパターンと組み合わせにくい
- 遅延生成ができない
- なぜそうしたかと問われるとうまく説明ができない

**用途**
- マルチスレッドを多用するバッチ
- tomcatなどで運用されるサーバサイドアプリケーション　
- 理想と現実の乖離に耐えられなくなって泣き出した開発者をなだめる
